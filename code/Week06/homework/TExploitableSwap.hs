{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Control.Monad           (replicateM, mapM, unless)
import           Plutus.Model         (Run, Ada (Lovelace),
                                       TypedValidator (TypedValidator),
                                       ada, adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue, newUser, UserSpend, Tx, userSpend, payToScript, DatumMode (HashDatum), spendScript, payToKey, spend, submitTx, utxoAt, currentTimeRad, validateIn, valueAt, logError)
import           PlutusTx.Prelude     (($), snd)
import           Prelude              (IO, (.), (<>), Monoid (mconcat), Eq ((==)), (&&), fst)
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)
import Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue))
import PlutusTx.Builtins

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" $ normalSpending 300
      , bad  "Double spending" $ doubleSpending 300
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------


scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

-- Set many users at once
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 2 $ newUser $ ada (Lovelace 1000)

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx beneficiary price usp val =
  mconcat
    [ userSpend usp
    , payToScript swapScript (HashDatum (OnChain.DatumSwap beneficiary price)) val
    ]

consumingTx :: PubKeyHash -> Integer -> () -> PubKeyHash -> TxOutRef -> Value -> UserSpend -> Tx
consumingTx beneficiary price redeemer consumer ref val sp2 =
  mconcat
    [ spendScript swapScript ref redeemer (OnChain.DatumSwap beneficiary price)
    , payToKey consumer val
    , payToKey beneficiary $ adaValue price
    , userSpend sp2
    ]

doubleConsumingTx :: PubKeyHash -> Integer -> () -> PubKeyHash -> TxOutRef -> TxOutRef -> Value -> UserSpend -> Tx
doubleConsumingTx beneficiary price redeemer consumer ref1 ref2 val sp2 =
  mconcat
    [ spendScript swapScript ref1 redeemer (OnChain.DatumSwap beneficiary price)
    , spendScript swapScript ref2 redeemer (OnChain.DatumSwap beneficiary price)
    , payToKey consumer val
    , payToKey consumer val
    , payToKey beneficiary $ adaValue price
    , userSpend sp2
    ]

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Integer -> Run ()
normalSpending price = do
  -- SETUP USERS
  [beneficiary, consumer] <- setupUsers
  -- USER 1 LOCKS 100 ADA ("val") IN VALIDATOR
  let val = adaValue 100                    -- Define value to be transfered
  sp1 <- spend beneficiary val                        -- Get user's UTXO that we should spend
  sp2 <- spend consumer $ adaValue price                        -- Get user's UTXO that we should spend
  submitTx beneficiary $ lockingTx beneficiary price sp1 val          -- User 1 submits "lockingTx" transaction
  -- WAIT FOR A BIT
  -- waitUntil waitBeforeConsumingTx
  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script
  let [(ref, out)] = utxos                  -- We know there is only one UTXO (the one we created before)
  ct <- currentTimeRad 100                  -- Create time interval with equal radius around current time
  tx <- validateIn ct $ consumingTx beneficiary price () consumer ref (txOutValue out) sp2  -- Build Tx
  submitTx consumer tx                            -- User 2 submits "consumingTx" transaction
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [beneficiary, consumer]                     -- Get final balances of both users
  unless (v1 == adaValue 1200 && v2 == adaValue 800) $  -- Check if final balances match expected balances
    logError "Final balances are incorrect"




doubleSpending :: Integer -> Run ()
doubleSpending price = do
  -- SETUP USERS
  [beneficiary, consumer] <- setupUsers
  -- USER 1 LOCKS 100 ADA ("val") IN VALIDATOR
  let val = adaValue 100                    -- Define value to be transfered
  sp1 <- spend beneficiary val                        -- Get user's UTXO that we should spend
  submitTx beneficiary $ lockingTx beneficiary price sp1 val          -- User 1 submits "lockingTx" transaction
  sp2 <- spend beneficiary val                        -- Get user's UTXO that we should spend
  submitTx beneficiary $ lockingTx beneficiary price sp2 val          -- User 1 submits "lockingTx" transaction
  sp3 <- spend consumer $ adaValue price                        -- Get user's UTXO that we should spend
    
  -- WAIT FOR A BIT
  -- waitUntil waitBeforeConsumingTx
  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script
  let [utxo1, utxo2] = utxos                  -- We know there is only one UTXO (the one we created before)
  ct <- currentTimeRad 100                  -- Create time interval with equal radius around current time
  tx <- validateIn ct $ doubleConsumingTx beneficiary price () consumer (fst utxo1) (fst utxo2) (txOutValue (snd utxo1)) sp3  -- Build Tx
  submitTx consumer tx                            -- User 2 submits "consumingTx" transaction
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [beneficiary, consumer]                     -- Get final balances of both users
  unless (v1 == adaValue 1200 && v2 == adaValue 900) $  -- Check if final balances match expected balances
    logError "Final balances are incorrect"
