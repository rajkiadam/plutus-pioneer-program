{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Control.Monad           (replicateM)
import           Plutus.Model         (Run, Ada (Lovelace),
                                       TypedValidator (TypedValidator),
                                       ada, adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue, newUser, UserSpend, Tx, userSpend, payToScript, DatumMode (HashDatum), spendScript, payToKey, spend, submitTx, waitUntil, utxoAt)
import           PlutusTx.Prelude     (($), Integer)
import           Prelude              (IO, (.), (<>), undefined, Monoid (mconcat))
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)
import Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef)
import PlutusTx.Builtins

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending
      , bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

-- Set many users at once
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 2 $ newUser $ ada (scToken 1000)

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx pkh price usp val =
  mconcat
    [ userSpend usp
    , payToScript swapScript (HashDatum (OnChain.DatumSwap pkh price)) val
    ]

consumingTx :: PubKeyHash -> Integer -> () -> PubKeyHash -> TxOutRef -> Value -> Tx
consumingTx pkh price redeemer usr ref val =
  mconcat
    [ spendScript swapScript ref redeemer (OnChain.DatumSwap pkh price)
    , payToKey usr val
    ]

doubleConsumingTx :: PubKeyHash -> Integer -> () -> PubKeyHash -> TxOutRef -> Value -> Tx
doubleConsumingTx pkh price redeemer usr ref val =
  mconcat
    [ spendScript swapScript ref redeemer (OnChain.DatumSwap pkh price)
    , spendScript swapScript ref redeemer (OnChain.DatumSwap pkh price)
    , payToKey usr val
    ]

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: PubKeyHash -> Integer -> () -> Run ()
normalSpending pkh price redeemer = do
  -- SETUP USERS
  [u1, u2] <- setupUsers
  -- USER 1 LOCKS 100 ADA ("val") IN VALIDATOR
  let val = adaValue 100                    -- Define value to be transfered
  sp <- spend u1 val                        -- Get user's UTXO that we should spend
  submitTx u1 $ lockingTx pkh price sp val          -- User 1 submits "lockingTx" transaction
  -- WAIT FOR A BIT
  -- waitUntil waitBeforeConsumingTx
  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script
  let [(ref, out)] = utxos                  -- We know there is only one UTXO (the one we created before)
  ct <- currentTimeRad 100                  -- Create time interval with equal radius around current time
  tx <- validateIn ct $ consumingTx d r u2 ref (txOutValue out)  -- Build Tx
  submitTx u2 tx                            -- User 2 submits "consumingTx" transaction
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless (v1 == adaValue 900 && v2 == adaValue 1100) $  -- Check if final balances match expected balances
    logError "Final balances are incorrect"




doubleSpending :: Run ()
doubleSpending = undefined